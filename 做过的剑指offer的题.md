[1.有序二维数组的查找](#1有序二维数组，二维数组的查找)  
[2.字符串空格替换](#2字符串空格替换)  
[3.从尾到头打印链表](#3从尾到头打印链表)  
[4.重建二叉树](#4重建二叉树)  
[5.用两个栈实现队列](#5用两个栈实现队列)  
[6.旋转数组的最小数字](#6旋转数组的最小数字)  
[7.斐波那契数列](#7斐波那契数列)  
[8.跳台阶](#8跳台阶)  
[9.变态跳台阶](#9变态跳台阶)  
[10.矩形覆盖](#10矩形覆盖)  
[11.二进制中1的个数](#11二进制中1的个数)  
[12.数值的整数次方](#12数值的整数次方)  
[13.调整数组顺序使奇数位于偶数前面，相对位置不变](#13调整数组顺序使奇数位于偶数前面，相对位置不变)  
[14.链表中倒数第k个节点](#14链表中倒数第k个节点)  
[15.反转链表](#15反转链表)  
[16.合并两个排序的链表](#16合并两个排序的链表)  
[17.树的子结构，判断b是不是a的子结构](#17树的子结构，判断b是不是a的子结构)  
[18.二叉树的镜像](#18二叉树的镜像)  
[19.顺时针打印矩阵](#19顺时针打印矩阵)  
[20.包含min函数的栈](#20包含min函数的栈)  
[21.栈的压入弹出序列](#21栈的压入弹出序列)  
[22.从上往下打印二叉树](#22从上往下打印二叉树)  
[23.判断序列是否是二叉搜索树的后序遍历序列](#23判断序列是否是二叉搜索树的后序遍历序列)  
[24.二叉树中和为某一值的路径](#24二叉树中和为某一值的路径)  
[25.复杂链表的复制](#25复杂链表的复制)  
[26.二叉搜索树转换成双向链表](#26二叉搜索树转换成双向链表)   
[27.字典序打印字符串的所有排列](#7字典序打印字符串的所有排列)  
[28.数组中出现次数超过一半的数字](#28数组中出现次数超过一半的数字)  
[29.最小的k个数](#29最小的k个数)  
[30.连续子数组的最大和](#30连续子数组的最大和)  
[31.计算整数中1出现的次数（从1到n整数中1出现的次数）](#31计算整数中1出现的次数（从1到n整数中1出现的次数）)  
[32.把数组排成最小的数](#32把数组排成最小的数)  
[33.求按从小到大顺序的所有丑数](#33求按从小到大顺序的所有丑数)  
[34.找到字符串中第一次只出现一次的字符，返回位置](#34找到字符串中第一次只出现一次的字符-返回位置)  
[35.统计数组中的逆序对个数对1000000007取模](#35统计数组中的逆序对个数对1000000007取模)  
[36.输入两个链表，找出他们的第一个公共节点](#36输入两个链表-找出他们的第一个公共节点)  
[37.统计一个数字在排序数组中出现的次数](#37统计一个数字在排序数组中出现的次数)  
[38.求树的深度](#38求树的深度)  
[39.数组中两个只出现一次的数字](#39数组中两个只出现一次的数字)  
[40.输出所有和为s的连续正数序列](#40输出所有和为s的连续正数序列)  
[41.和为S的两个数字且乘积最小](#41和为S的两个数字且乘积最小)  
[42.左旋转字符串](#42左旋转字符串)  
[43.翻转单词顺序列](#43翻转单词顺序列)  
[44.扑克牌顺子](#44扑克牌顺子)  
[45.圆圈中最后剩下的数](#45圆圈中最后剩下的数)  
[46.求1+2+3+4+5+...n-不能使用乘除法-条件判断if-各种循环for-while-三目运算符等](#46求1+2+3+4+5+...n-不能使用乘除法-条件判断if-各种循环for-while-三目运算符等)  
[47.不使用加减乘除实现加法](#47不使用加减乘除实现加法)  
[48.字符串转换成整数](#48字符串转换成整数)  
[49.数组中重复的数字](#49数组中重复的数字)  
[50.构建乘积数组、给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]*A[i+1]…*A[n-1]-不能使用除法。](#50构建乘积数组、给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]*A[i+1]…*A[n-1]-不能使用除法。)  
[51.有序二维数组的查找](#####1有序二维数组，二维数组的查找)  
[52.有序二维数组的查找](#####1有序二维数组，二维数组的查找)  
[53.有序二维数组的查找](#####1有序二维数组，二维数组的查找)  
[54.有序二维数组的查找](#####1有序二维数组，二维数组的查找)  
[55.有序二维数组的查找](#####1有序二维数组，二维数组的查找)  
[56.有序二维数组的查找](#####1有序二维数组，二维数组的查找)  
[57.有序二维数组的查找](#####1有序二维数组，二维数组的查找)  
[58.有序二维数组的查找](#####1有序二维数组，二维数组的查找)    
[59.有序二维数组的查找](#####1有序二维数组，二维数组的查找)
[60.有序二维数组的查找](#####1有序二维数组，二维数组的查找)
[61.有序二维数组的查找](#####1有序二维数组，二维数组的查找)
[62.有序二维数组的查找](#####1有序二维数组，二维数组的查找)
[63.有序二维数组的查找](#####1有序二维数组，二维数组的查找)
[64.有序二维数组的查找](#####1有序二维数组，二维数组的查找)
[65.有序二维数组的查找](#####1有序二维数组，二维数组的查找)

##### 1有序二维数组，二维数组的查找
    利用矩阵的有序性，行列交叉排除，左下或者右上刚好满足最少比较条件。
##### 2字符串空格替换
    注意利用string的charAt方法
    字符串可以直接 str += "111";这样
    StringBuffer类性能比string类好，但是没有[i]属性,只能.charAt(i)

##### 3从尾到头打印链表

```
//超简洁递归版本，注意list要是全局变量，才能在每次递归的时候都使上一层的改变生效
public class Solution {
    ArrayList<Integer> arrayList=new ArrayList<Integer>();
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        if(listNode!=null){
            this.printListFromTailToHead(listNode.next);
            arrayList.add(listNode.val);
        }
        return arrayList;
    }
}
```

##### 4重建二叉树
```
//关键点：每个子树前序中序的节点数是一样的，可以利用这点划分出每个子树的前序中序,使用递归。
//就是重建左右子树的前序和中序遍历。
//每次递归，连接根节点的左右子树的递归重建函数。
//然后返回根节点

/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    
	public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        int inlen = in.length;//记录大小便于遍历
        int minin = 0;//记录中序遍历中根节点位置的变量
        if(inlen == 0){//处理空值
            return null;
        }
//        vector<int> left_in, left_pre, right_in, right_pre;//创建左右子树
        TreeNode head = new TreeNode(pre[0]);//前序头结点为根节点
        for(int i = 0;i < inlen; i++){//找出中序遍历中根节点位置
            if(head.val == in[i]){
                minin = i;
                break;
            }
        }
        //创建左右子前中序遍历，左子树遍历大小都是minin
        int[] left_in = new int[minin];
        int[] left_pre = new int[minin];
        int[] right_in = new int[inlen-minin-1];
        int[] right_pre = new int[inlen-minin-1];
        for(int i = 0; i < minin; i++){//中序根节点左侧为左子树中序遍历，同时左子树前序也为同样个数，因此这里可以同时处理
            left_in[i] = in[i];
            left_pre[i] = pre[i+1];//前序头结点为根节点
        }
        for(int i = minin+1; i < inlen; i++){//同理添加右子树的中序和前序
            right_in[i - minin - 1] = in[i];
            right_pre[i - minin - 1] = pre[i];
        }
        head.left = reConstructBinaryTree(left_pre,left_in);
        head.right = reConstructBinaryTree(right_pre,right_in);
        return head;
    }
```

##### 5用两个栈实现队列

```
import java.util.Stack;

public class Solution {//思路是1只压入，2只出栈，出栈的2没了就从栈1全转移到栈2，再从2出栈
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
        stack1.push(new Integer(node));//1作为直接压入 栈
    }
    
    public int pop() {
    if(stack2.empty()){//只要2为空，就从1中压入所有元素
        while (!stack1.empty()){//1没空就全压到2中，这样1中先入得2就能先出
            stack2.push(stack1.pop());
        }
    }
        return stack2.pop();//若2不空或者从 1出栈压到2结束了，就从2栈顶出栈，顺序是对的
    }
}
```

##### 6旋转数组的最小数字

```
//这里就是最简单的看规律，如果遍历到了，左边比右边大的，说明找到旋转的地方了。
//直接返回就是最小值了，因为原来的数组是非严格递增的。
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if(array.length == 0){
            return 0;
        }
        for(int i = array.length - 1;i >= 2; i--){
            if(array[i] < array[i - 1]){
                return array[i];
            }
        }
        return array[0];//为1的情况
    }
}
//事实上这种比较low，下面二分法比较高端，想知道的是，最初怎么知道right-left=1时，返回right
```


```
//思想：二分法，一个while解决。每次循环取middle。判断旋转的位置在左边还是右边。每次选旋转所在的区间继续循环。
import java.util.ArrayList;
public class Solution {
//假定数组左半部分是旋转过去的，右半部分是原来的顺序。
public int minNumberInRotateArray(int[] array) {
        if (array.length == 0)
            return 0;
        int left = 0;
        int right = array.length - 1;
        int middle = -1;
        //事实上只要进去循环了就不可能出现左小右大的情况，因为每次都选的是左大右小的    区间。结束条件只可能是right-left=1
        while (array[left]>=array[right]) {
            //只有这里是结束条件，最后只剩下两个数，左大右小
            //循环里面是不可能出现左小右大的情况的
            if(right-left==1){
                middle = right;
                break;
            }
            middle = left + (right - left) / 2;
            //如果中间位置还是旋转的部分，那么最小值在middle和right之间
            if (array[middle] >= array[left]) {
                left = middle;
            }
            //如果中间位置是原数组位置，那么最小值在left和middle之间
            if (array[middle] <= array[right]) {
                right = middle;
            }
        }
        return array[middle];
    }
}
```

```
//扩展：如果是非严格递增数列，就不能判断了，就需要顺序判断，检查条件是左index=中index=右index
```


##### 7斐波那契数列

```
//本来想到的是简单的for循环，但是查了一下斐波那契数列，知道了f(n)=f(n-1)+f(n-2)
//另外就是要注意边界值0，没有考虑到
    public int Fibonacci(int n) {
        if(n == 0){
            return 0;
        }
        if(n <= 2){
            return 1;
        }
        return Fibonacci(n - 1)+Fibonacci( n - 2);
    }
```

##### 8跳台阶

```
//开始想错了，差两级时候虽然有两种跳法，但是其实有一种包含在差一级的情况
    public int JumpFloor(int target) {
        if(target == 0){
            return 0;
        }
        if(target == 1){
            return 1;
        }
        if(target == 2){
            return 2;
        }
        return JumpFloor(target - 1)+JumpFloor(target - 2);
    }
```

##### 9变态跳台阶

```
//这道题不会，想用递归，后来小心告诉我是规律题，找个数找错了好几次，发现是2^（n-1）
//感觉这样不太好，不正式，又看答案，原来f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n) 
//后面就是第一次跳几级之后剩下的有多少种， f(n) = f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n) => f(0) + f(1) //+ f(2) + f(3) + ... + f(n-1)= f(n-1) + f(n-1)
//这样就能继续用递归了
//还有一种是直接用规律，可以使用位运算符一行搞定。
public class Solution {
    public int JumpFloorII(int target) {
         if(target == 0){
             return 0;
         }
        if(target == 1){
            return 1;
        }
        return 2*JumpFloorII(target - 1);
    }
}
```

##### 10矩形覆盖

```
//快被自己蠢哭了，没想到现在这么笨，没救了。
//瞎他妈找了半天规律，找递归。
//直接假定第一个放横的还是竖的，都是算一种剩下的就是n-1//阶或者n-2阶
   public int RectCover(int target) {
        if(target == 1){
            return 1;
        }
        if(target < 1){
            return 0;
        }
        if(target == 2){
            return 2;
        }
        return RectCover(target - 1) + RectCover(target - 2);
    }
```

##### 11二进制中1的个数

```
//事实证明，我就是很笨，并不是一时的。想了半天各种条件 ，对数，
//最后原来根本不对，浪费时间
//既然是二进制了，就想位运算符啊，蠢货
    public int NumberOf1(int n) {
        int flag = 1, count =0;
        while(flag != 0){
            if((flag & n) != 0){
                count ++;
            }
            flag = flag << 1;
        }
        return count;
    }
最优解
    public int NumberOf1(int n) {
        int count = 0;
        while(n != 0){
            count ++;
            //每次n-1都会把最右边的1变成0，然后其后边的0变成1，然后每次相与结果就相当于原来的数减少了最后面的一个1
            n = n&(n-1);
        }
        return count;
    }
```

##### 12数值的整数次方

```
//自己写的简直low
    public double Power(double base, int exponent) {
        return Math.pow(base, exponent);
  }
//快速幂
//所谓快速幂，核心思想就是将被乘数base以指数级增长base*base，避免一次一次的乘base。达到快速得到需要的次方结果。
//其实最重要的就是幂次为负时候就是正数时候的-1次方，就是变成分子为1的分数的分母，因此幂次需要直接变成正数求结果，最后返回的时候再看幂次正负返回不同的值，就是干扰项跟正常有联系的时候，只看正常的，最后再考虑干扰项返回，算是解耦吧。
    public double Power(double base, int exponent) {//没处理分母为0的情况，就是exponent<0但是base也是小于0的情况
        int n = Math.abs(exponent);
        double mi = 1;//存储最后结果
        if(base == 0){//0为底任何次幂都是0
                return 0;
        }
        if(base > 0){//底大于0的情况
            while(n!=0){//次幂还没等于0
                if ((n&1)==1){//看次幂有多大，二进制每过一个数，要乘的已经翻倍，2次幂么，实际上就是计算大小，计算需要乘多少个。
                    mi *= base;
                }
                base*=base;
                n>>=1;
            }
        }
        else{//底小于0的时候看幂次是奇数还是偶数，奇数结果是负数，大小跟正数时候一样，因此直接返回正数结果就可以。
            if(n%2 == 1){
                return -1*Power(-base, n);
            }
             else
                 return Power(-base, n);
        }
        return exponent < 0 ? 1/ mi : mi;//如果幂次小于0，相当于正的幂次加上-1次方。      
  }
```

##### 13调整数组顺序使奇数位于偶数前面，相对位置不变

```
//这道题方法写对了，但是最后将newarray赋回array的时候，直接赋回不行，还要遍历一个一个赋值，麻烦。
public void reOrderArray(int [] array) {//不是说保持相对位置不变么，书上开始那种不是显然不行么
        int[] newarray = new int[array.length];
        int count1 = 0；
        int count2 = array.length - 1;
        //从头开始顺序遍历奇数元素，添加到新数组前面。
        for(int i = 0; i < array.length; i++){
            if(array[i] % 2 == 1){
                newarray[count1] = array[i];
                count1++;
            }
        }
        //从尾开始遍历偶数元素，添加到新数组后面
        for(int j = array.length - 1; j >= 0; j--){
            if(array[j] % 2 == 0){
                newarray[count2] = array[j];
                count2--;
            }
        }
        //将新数组赋给原数组
        for(int i=0;i<array.length;i++){
            array[i]=newarray[i];
        }
    }
```
//还有一种思路，类似冒泡排序，两层循环，每次如果相邻两个数前偶后奇，交换两个的位置
//下面代码是抄的，是python的

```
class Solution {
public:
    void reOrderArray(vector<int> &array) {
        for (int i = 0; i < array.size();i++)
        {
           for (int j = array.size() - 1; j>i;j--)
           {
                if (array[j] % 2 == 1 && array[j - 1]%2 == 0) //前偶后奇交换
                {
                    swap(array[j], array[j-1]);
                }
            }
        }
    }
};
```

##### 14链表中倒数第k个节点

```
//思想就是两个指针，一个先走k，然后另一个开始在头一起走。
//这题还能有点印象，还行，但是要注意代码的鲁棒性，和正确性，不防假设几个边界值，比如输入分别为空之类的。
    public ListNode FindKthToTail(ListNode head,int k) {
        if(k <= 0 ||  head == null){//这里开始写成head.next==null，但是这样就是链表有值，应该是可以做的，链表为空才不行，应直接判断head
            return null;
        }
        ListNode k1 = head, k2 = head;
        for(int i = 1; i < k; i++){//这里开始写为0了，但是注意，不妨想倒数第一个，就是最后一个，k1k2应在一起相隔0，这里就不该有一次循环了。
            if(k1.next != null){
                k1 = k1.next;
            }
            else
                return null;
        }
        while(k1.next != null){
            k1 = k1.next;
            k2 = k2.next;
        }
        return k2;
    }
```

> - 相关题目：求链表中间节点。两个指针一个每次走一步，一个每次走两步。   
> - 判断一个单向链表是否形成了环形结构。快慢指针，看是否快的先到尾节点（下一节点为空）还是快的先追上慢的。   
> - 举一反三：指针遍历链表不能解决问题的时候，可以尝试用两个指针遍历链表，一快一慢，或者先走若干步。
##### 15反转链表

```
//思路：从头到尾三个节点依次翻转就行了
//很简单的一道题，但是一直想递归，没想出来，开始又用三个节点翻转，不行，太复杂，后来改用两个节点翻转，没注意输出是什么。
    public ListNode ReverseList(ListNode head) {
        ListNode prenode = null;
        ListNode nextnode = null;
        while(head != null){
                nextnode = head.next;//记录二个节点
                head.next = prenode;//第一个节点的下一个节点是上一个
                prenode = head;//此时需要记录下一个节点，否则next就改了
                head = nextnode;//为下一次循环准备
            }
//        while(prenode != null){//注意反转后的头结点是prenode
//            System.out.print(prenode.val);
//            prenode = prenode.next;
//        }
        if(prenode != null)//只要初始head不为空就有prenode
            return prenode;
        else
            return head;//如果head=null时直接返回
    }
```

##### 16合并两个排序的链表

```
//思想：递归拼接，比较大小list.next递归 return list；
//这道题出现了非常多的错误，测试用例考虑的完全不够周全
//看了下别人写的递归算法，太厉害了 
//别人的递归
 public ListNode Merge(ListNode list1,ListNode list2) {
        if(list1 == null){
            return list2;
        }
        if(list2 == null){
            return list1;
        }
        if(list1.val < list2.val){
            list1.next = Merge(list1.next, list2);
            return list1;
        }
        else{
            list2.next = Merge(list1, list2.next);
            return list2;
        }
    }
```



##### 17树的子结构，判断b是不是a的子结构

```
//思想：主从函数，主函数递归从root1中找到root2的根节点，从函数前序遍历，对比root1和root2
//直接递归比较左右子树就行，开始想的太复杂，然后又把结束条件想错了，结束条件应该是子树遍历完，全对上就行，1树不用管，想的不够多就
//开始敲了。看了答案。
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {//主函数在root1中找root2的根节点，一旦找到就从此节点开始比较
        boolean result = false;
        if(root1 == null || root2 == null){
            return false;
        }
        if(root1.val == root2.val){
            result = IfSubtree(root1,root2);
        }
        if(result == false){
            return (HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2));
        }
        return result;
    }
    boolean IfSubtree(TreeNode root1, TreeNode root2){//副函数负责从root1中选定节点开始前序比较是否是子结构
        if(root2 == null){//开始的遍历条件写错了，不是全为空才是正确的，正确的是2遍历完了，1可以有剩余
            return true;
        }
        if(root1 == null)//如果1遍历完了，2还没遍历完，说明不是子结构
            return false;
        if(root1.val == root2.val){//返回多个函数的与，先比较根节点的值，前序遍历
            return IfSubtree(root1.left, root2.left) && IfSubtree(root1.right, root2.right);
        }
        return false;
    }
}
```

##### 18二叉树的镜像

```
//思想：直接递归互换左右子树
//这道题想到递归就比较简单了，其实是输入描述的图给了启发，有时候需要画图理解
    public void Mirror(TreeNode root) {
        TreeNode tmp;
        if(root != null){
            tmp = root.left;
            root.left = root.right;
            root.right = tmp;
            Mirror(root.left);
            Mirror(root.right);
        }
        return;
    }
```

##### 19顺时针打印矩阵

```
//做了快一天，思想和剑指offer上面的一样，但是自己写的修修补补好麻烦
import java.util.ArrayList;
public class Solution {
//    int x = 0;留着当做教训吧，ArrayList的add方法都不知道，还想跟数组一样添加元素
    public ArrayList<Integer> printMatrix(int [][] matrix) {
        ArrayList<Integer> array = new ArrayList<Integer>();
        if(matrix.length == 1){
            for(int i = 0;i < matrix[0].length;i++){
                array.add(matrix[0][i]);
            }
            return array;
        }
        if(matrix[0].length == 1){
            for(int i = 0;i < matrix.length;i++){
                array.add(matrix[i][0]);
            }
            return array;
        }
        for(int i = 0,j = 0; i <= ((matrix.length-1)/2) && i <= ((matrix[0].length-1)/2); i++,j++){
            printcircle(i, j, matrix, array);
        }
        return array;
    }
    static ArrayList<Integer> printcircle(int i,int j,int[][] matrix,ArrayList<Integer> array){
        int i0 = i,j0 = j;
        while(j <= (matrix[0].length - j0 - 1)){//上
            array.add(matrix[i][j]);
            j++;
        }
        j--;
        i++;
        if(i > (matrix.length - i0 - 1))
            return array;
        while(i <= (matrix.length - i0 - 1)){//右
            array.add(matrix[i][j]);
            i++;
        }
        i--;//是这里的问题，上面的循环可能没执行，但是还是减一了
        j--;
        if(j < j0){
            return array;
        }
        while(j >= j0){//下
            array.add(matrix[i][j]);
            j--;
        }
        j++;
        i--;
        if(i <= i0){
            return array;
        }
        while(i > i0){//左
            array.add(matrix[i][j]);
            i--;
        }
        return array;
    }
}
```


```
//记录一种比较好的方法
    思想，用左上和右下的坐标定位出一次要旋转打印的数据，一次旋转打印结束后，往对角分别前进和后退一个单位。
    提交代码时，主要的问题出在没有控制好后两个for循环，需要加入条件判断，防止出现单行或者单列的情况。
 */
class Solution {
public:
    vector<int> printMatrix(vector<vector<int> > matrix) {
        int row = matrix.size();
        int col = matrix[0].size();
        vector<int> res;
         
        // 输入的二维数组非法，返回空的数组
        if (row == 0 || col == 0)  return res;
         
        // 定义四个关键变量，表示左上和右下的打印范围
        int left = 0, top = 0, right = col - 1, bottom = row - 1;
        //截止条件左右和上下之间有剩余，或者至少有一行或者一列就是=的情况。
        while (left <= right && top <= bottom)
        {
            // 从左到右
            for (int i = left; i <= right; ++i)  res.push_back(matrix[top][i]);
            // 从上到下
            for (int i = top + 1; i <= bottom; ++i)  res.push_back(matrix[i][right]);
            // 从右到左
            if (top != bottom)
            for (int i = right - 1; i >= left; --i)  res.push_back(matrix[bottom][i]);
            // 从下到上
            if (left != right)
            for (int i = bottom - 1; i > top; --i)  res.push_back(matrix[i][left]);
            left++,top++,right--,bottom--;
        }
        return res;
    }
};
```

##### 20包含min函数的栈

```
//思想：构造一个辅助栈，辅助栈保存的是原始栈从栈底到当前位置的最小值，入栈的时候比较辅助栈顶元素，决定是否需要更新要添加的辅助栈最小值，否则辅助栈继续添加自己的栈顶元素。
//这道题看答案了，没太看懂题目的意思，知道思想后就简单了，中间把Stack的判空条件想成null了，实际上有isEmpty()方法。
//另外这道题的分类是举例子，有具体到一般，没思路的时候带进去几个一般的例子。
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();//stack1是原始序列
    Stack<Integer> stack2 = new Stack<Integer>();//stack2表示栈底到现在位置之间的最小值
    public void push(int node) {
        stack1.push(node);
        if(stack2.isEmpty() || (stack2.peek() > node)){//如果栈2是空的，或者栈2当前最小值比压入的值大
            stack2.push(node);//向2压入当前输入的值
        }
        else{
            int tmp = stack2.peek();//否则，当前的最小值到最新的位置，还是最小的，那么把栈顶元素重新压入一遍
            stack2.push(tmp);
        }
    }
    public void pop() {//出栈的时候直接出栈
        stack1.pop();
        stack2.pop();
    }
    
    public int top() {//top找出当前栈顶的元素
        return stack1.peek();
    }
    
    public int min() {//min函数返回但前辅助栈2顶的元素。
        return stack2.peek();
    }
}
```

##### 21栈的压入弹出序列

```
//思想就是建立一个辅助栈，循环向里面压栈，while判断如果栈顶元素等于当前弹出序列，出栈，不等就直接下一次for循环。最后如果辅助栈空了说明是弹出序列。
//惭愧啊，自己写的实在是不想再看一遍了，直接复制大神的解法和思想
import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
        if(pushA.length == 0 || popA.length == 0)
            return false;
        Stack<Integer> s = new Stack<Integer>();
        //用于标识弹出元素在popA中的位置
        int popIndex = 0;
        for(int i = 0; i< pushA.length;i++){
            s.push(pushA[i]);
            //如果栈不为空，且栈顶元素等于弹出序列
            while(!s.empty() &&s.peek() == popA[popIndex]){
                //出栈
                s.pop();
                //弹出序列向后一位
                popIndex++;
            }
        }
        return s.empty();
    }
}
```

##### 22从上往下打印二叉树

```
//思想：建立队列
//这道题好像是数据结构书里面的，考研的时候会，怎么现在就不会了呢
//又看答案了，要点是用队列，有时候感觉各种循环不行的时候就考虑一下特殊结构，队列啊，栈啊，链表啊
    public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
        ArrayList<Integer> tree = new ArrayList<Integer>();
        Queue<TreeNode> que = new LinkedList<TreeNode>();
        que.offer(root);
        if(root == null){
            return tree;
        }
            root = que.poll();
            if(root.left != null){
                que.offer(root.left);
            }
            if(root.right != null){
                que.offer(root.right);
            }
            tree.add(root.val);
        }
        return tree;
    }
```

##### 23判断序列是否是二叉搜索树的后序遍历序列

```
//思想：利用二叉搜索树的性质，后序遍历最后边是根节点，向前遍历找到左子树的根节点，然后遍历左子树保证都小于根节点。右子树已经遍历过了，然后重新构造左右子树的后序遍历序列，然后判断左右子树的序列是不是。
//想了好久就是不会，看了答案好简单，结果调试了半天，各种情况没处理好，还有循环的值加错了
//的不是第一次了
public class Solution {
    public boolean VerifySquenceOfBST(int [] sequence) {
        if(sequence.length == 0){
            return false;
        }
        if(sequence.length == 1){
            return true;
        }
        int root = sequence[sequence.length - 1];//根节点的值
        int i = sequence.length - 2;
        while (sequence[i] > root && i > 0){//找左子树根节点，因为右子树的值都比根节点大：事实上这里就是验证右子树
            i--;
        }
		if(i != 0 ){
			for(int j = i; j >= 0; j--){//如果左子树有大于root节点的返回false：事实上这里就是验证左子树
				if(sequence[j] >= root){
					return false;
				}
			}
		}
		// 下面都是为了递归做准备
        int[] left = new int[i + 1];//初始化左子树数组
        int[] right = new int[sequence.length - i - 1];//初始化右子树数组
        for(int k = 0; k < i + 1; k++){//构建左子树
            left[k] = sequence[k];
        }
        for(int k = i + 1; k < sequence.length; k++){//构建右子树
            right[k - i - 1] = sequence[k];
        }
        VerifySquenceOfBST(left);//检验左子树
        VerifySquenceOfBST(right);//检验右子树
        return true;//没有返回false就是true
    }
}
```

##### 24二叉树中和为某一值的路径

```
//思想：创建listall包含所有路径，list当前路径。加入当前节点判断是否符合路径和值条件符合加入到listall，否则前序遍历继续左右子树。注意叶子节点return打断。
//路径的定义是从根节点到叶子节点
//这道题自己写的其实跟答案差不多，但是还是没解出来，答案的递归不是很明白，问了睿哥，知道
//了怎么回事，递归后面的return返回上一层，如果不是赋值的，就是用来打断的
import java.util.ArrayList;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    int count = 0;
    ArrayList<ArrayList<Integer>> listAll = new ArrayList<ArrayList<Integer>>();//存储已经选好的路径，只会增加
    ArrayList<Integer> list = new ArrayList<Integer>();//存储每次可能路径，变化的。。可能增加，也可能减少。
    public ArrayList<ArrayList<Integer>> FindPath(TreeNode root,int target) {
        if(root == null) return listAll;//这里主要起到最后叶子节点的递归中断作用，在上层函数位置返回的值并没有处理，无影响。返回listAlll是因为只有listall是符合返回类型的变量
        list.add(root.val);//当前节点加入list
        target -= root.val;//判断条件更新
		// 就一句核心
        if(target == 0 && root.left == null && root.right == null)//主要业务操作，（满足叶子结点、路径值条件，加入）
            listAll.add(new ArrayList<Integer>(list));
		// 下面是递归过程
        FindPath(root.left, target);//遍历左子树
        FindPath(root.right, target);//遍历右子树
		// 第三遍看，感觉这个不好理解啊。这个是在出栈时调用栈栈顶第一次执行。
        list.remove(list.size()-1);//(好像是因为下一层遍历左子树会改变list，删除最后一个，返回上一层使list从当前节点开始，好遍历右子树)
    //感觉原来的想法不太准确，这个去掉的是当前节点，当前节点及其子路径已经找完了，那么此时应该到上一层，然后继续寻找上一层未找的路径，比如当前是上层左子树，那么该找右子树了。每一层的root节点都是那一层的，不会改变。list存储的只是路径。
        return listAll;//返回最终listall，递归过程中的return实际上没有意义，因为listAll是全局变量才使得递归有意义
    }
```

##### 25复杂链表的复制

```
//思想：先从头到尾复制节点，复制的节点插入到被复制的节点和next之间。然后从头到尾复制random节点，就是原来的random.next。最后分离复制的链表和原链表。
//这题不会，感觉自己写的也行，但是结果是空，一句一句跟人家的对完，一样了之后能运行，但是最后一个循环改了之后就不行了
//另外这题实际上已经写了两天了，第一天看了一天没看懂题，第二天看了快一天，没看懂自己哪错了。
//问了小薪，结果连第一个循环都看不懂，还非说不对，明明是高票答案+能运行+数据结构标准写法。解释了半天没懂，费了半天劲画了张图，不
//看。气懵了。
/*
public class RandomListNode {
    int label;
    RandomListNode next = null;
    RandomListNode random = null;

    RandomListNode(int label) {
        this.label = label;
    }
}
*/
public class Solution {
    public RandomListNode Clone(RandomListNode pHead)
    {
        //先复制节点的next
        if(pHead == null){
            return null;
        }
        RandomListNode pHead0 = pHead;
        while(pHead0 != null){
            //将复制的节点插入到头结点和他下一个节点之间
            RandomListNode pHeaddup = new RandomListNode(pHead0.label);//新建复制节点
            pHeaddup.next = pHead0.next;//将头结点的下一个作为复制节点的下一个
            pHead0.next = pHeaddup;//头结点的下一个改为复制节点
            pHead0 = pHeaddup.next;//后移
        }
        //再复制random
        pHead0 = pHead;
        while(pHead0 != null){//这里不用判断pHead.next == null因为pHead.next是复制节点一定不为空
            if(pHead0.random != null){//这里注意不是所有的节点都有random的，因此要判断一下，太马虎了，考虑的不够周全
                pHead0.next.random = pHead0.random.next;
            }
            pHead0 = pHead0.next.next;
        }
        //分离复制的链表
        RandomListNode pHead2 = pHead.next;//复制链表头节点
        RandomListNode pHead3 = pHead;//循环原始链表节点
        pHead0 = pHead2;//循环复制链表节点
        while(pHead0.next != null){
            pHead3.next = pHead3.next.next;//构造原链表
            pHead0.next = pHead0.next.next;//构造复制的链表
            pHead3 = pHead3.next;
            pHead0 = pHead0.next;
        }
        return pHead2;
    }
}
```

##### 26二叉搜索树转换成双向链表

```
//思想：空值返回空，无子节点返回子节点，构造左子树，定位左子树最右节点，root添加到左子树右边。右子树构造，添加右子树到root右边。判断左子树是否为空决定返回left还是root
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public TreeNode Convert(TreeNode root) {
        if(root==null)
            return null;
        if(root.left==null&&root.right==null)
            return root;
        // 1.将左子树构造成双链表，并返回链表头节点
        TreeNode left = Convert(root.left);
        TreeNode p = left;
		
        // 2.定位至左子树双链表最后一个节点
        while(p!=null&&p.right!=null){
            p = p.right;
        }
        // 3.如果左子树链表不为空的话，将当前root追加到左子树链表
        if(left!=null){
            p.right = root;
            root.left = p;
        }
		
        // 4.将右子树构造成双链表，并返回链表头节点
        TreeNode right = Convert(root.right);
        // 5.如果右子树链表不为空的话，将该链表追加到root节点之后
        if(right!=null){
            right.left = root;
            root.right = right;
        }
        return left!=null?left:root;
    }
}
```

##### 27字典序打印字符串的所有排列

```
//思考：这道题感觉还挺难的，就是交换递归到的元素和它后面所有元素。递归，到头之后向集合中添加这次的排列。注意递归回来之后要交换回来交换的元素。
//简略思想：for i设定每次开头的元素。递归找剩余元素的全排列。剩余元素为1个的时候，添加当前顺序的str。
//思想就是：for i用来循环每次作为开头的元素。每次递归之前交换第i个和第1个的元素，递归之后也交换，以便不影响下一次的查找。
//          递归过程就是交换之后，假定这次开头已经是某元素了。找除了第一个之后剩下的全排列，结束条件就是。如果参数只剩下一个就直接返回当前的str。
//重点是回溯法，我称之为循环递归法，类似于双重循环，但是内循环像是变成了递归
//还有就是set可以直接避免重复元素，省掉了判断。
import java.util.*;
public class Solution {
public ArrayList Permutation(String str) {//自己的想法是for循环每一个字符串元素，取出来，递归剩下的元素，细节待完善，但是写了个开头写不下去了，不知道用什么格式遍历字符串
        //回溯法，自己称之为循环递归法
        HashSet<String> hash =new HashSet<String>();
        if(str != null){
            huisu(str.toCharArray(), hash, 0);
        }
        ArrayList<String> list = new ArrayList<String>();
        list.addAll(hash);
        Collections.sort(list);
        return list;
    }
	
    void huisu(char[] str, HashSet<String> hash, int k){
        if(k == str.length - 1){
            String val = String.valueOf(str);
                hash.add(val);
        }
        else{
            for(int i = k; i < str.length; i++){
                swap(str, i , k);
                huisu(str, hash, k+1);
                swap(str, i , k);
            }
        }
    }
    static void swap(char[] cs, int i, int j) {
        char temp = cs[i];
        cs[i] = cs[j];
        cs[j] = temp;
    }
}
```

##### 28数组中出现次数超过一半的数字

```
//思想1: 中位数就一定是这个数字。然后利用Partition函数进行求解，如果选定关键字的index(就是partition函数每次迭代之后排列的index)是2/n就直接找到了，否则大于就是在左边，小于就是在右边。递归查找
//      （首先需要知道快速排序的基础 Partition函数，首先选一个元素，放到尾，然后从尾开始遍历。记录较大序列的左边界，如果右边有小于关键字的，和左边界交换，右移左边界。最后交换左边界和尾元素，此时左边界的左边都是小的右边界都是大的。返回关键字的index）
//思想2：大于1/2的元素比所有元素都多，因此建立两个变量。一个变量记录当前的元素是什么，另一个变量记当前元素的次数，如果遍历到的不是次数--如果是次数++。如果次数为0则更新当前元素。最后剩下的元素就是大于1/2的元素。时间复杂度是n空间复杂度是1
//思想3：建立一个hashmap，顺序遍历，如果不包含加入。如果包含value++，判断是否value> l/2。这种时间复杂度是n但是空间复杂度也是n。
//两点需要注意，一个是传入为空的情况，另一个是判断结果是否符合超过一半，因为两种解法的出的结果不一定超过一半，hashmap的方法不用判断这个。
import java.util.*;
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        if(array == null || array.length <= 0){
            return 0;
        }
        //两种解法，第一种类似递归的快速查找循环思路，第二种利用数组的规律，大于1/2的元素比其他所有元素加起来都多
        //第三种是我自己写的hashmap的
        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();
         
        for(int i=0;i<array.length;i++){
             
            if(!map.containsKey(array[i])){
               map.put(array[i],1);
            }else{
                int count = map.get(array[i]);
                map.put(array[i],++count);
            }
            if(map.get(array[i]) > (array.length / 2)){
                return array[i];
            }
        }
        return 0;
    }
}
```

##### 29最小的k个数

```
//思想1：参考上面的题使用Partition函数，直接找下标为k的元素，如果大于就在左边，如果小于就在右边。
//思想2: 大顶堆。每次和对顶元素比较，如果小于堆顶个元素去掉对顶元素，插入。如果大于堆顶元素，抛弃当前元素。java优先队列是堆实现的，但是要注意默认是小顶堆，需要自定义比较器。
//好像还行，没有给出异常输入的处理
//这个是o(kn)的解法，使用Partition函数可以有O(n)的解法，直接找第k个数字，每次按所取随机数的大的和小的左右分，找第k个所在区间直到找到序号为k-1的元素
//缺点是需要更改源数组元素，但是直接使用复制的数组进行查找是不是可行？
//还有一种处理海量数据的方法，使用二叉树数据结构，实现一个大小为k的容器，循环替换容器中的最大数字，容易想到使用最大堆
//思想2实现：
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.Comparator;

public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int[] imput, int k){
    //结果list
        ArrayList<Integer> result = new ArrayList<Integer>();
        int length = input.length;
        if(k > length || k == 0){
            return result;
        }
        //通过优先队列创建大顶堆。默认是小顶堆,需要自定义比较器
        PriotiryQueue<Integer> maxHeap = new PriorityQueue<Integer>(k, new Comparator<Integer>(){
            public int compare(Integer e1, Integer e2){
                return e2.compareTo(e1);
            }
        });
        for (int i = 0; i < length; i++){
            if (maxHeap.size() != k){
                maxHeap.offer(input[i])
            }else if (maxHeap.peek() > input[i]){
                Integer temp = maxHeap.poll();
                temp = null;
                maxHeap.offer(input[i]);
            }
        }
        for (Integer integer :  maxHeap){
            result.add(integer);
        }
        return result;
    }
}
//思想3实现：
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int[] input, int k) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        if(input == null || k > input.length || k < 0){
            return list;
        }
        for(int i = 0; i < k; i++){
            int temp = input[0];
            int m = 0;
            for(int j = 0; j < input.length; j++){
                if(temp > input[j]){
                    temp = input[j];
                    m = j;
                }
            }
            list.add(input[m]);
            input[m] = Integer.MAX_VALUE;
        }
        return list;
    }
}
```

##### 30连续子数组的最大和

```
//显然意义不大，枚举法
//思想：嵌套两个for循环。表示起止位置，然后中间计算和。
public class Solution {
    public int FindGreatestSumOfSubArray(int[] array) {
        if(array == null || array.length == 0){
            return 0;
        }
        int tmp = 0;
        int max = -99;
        for(int i = 0; i < array.length; i++){
            for(int j = i + 1; j < array.length; j++){
                for(int k = i;k <= j; k++){
                    tmp += array[k];
                    if(tmp > max){
                        max = tmp;
                    }
                }
                tmp = 0;
            }
        }
        return max;
    }
}
//动态规划，不知道算不算动态规划。
//思想：直接循环累加，如果加到0了，重新计算，每次循环都判断当前是否是最大的
//正解是很简单的动态规划或者直接找规律
//动态规划使用递归思想，但是解决用的循环。即f(n-1)如果不大于零就舍去，重新开始计算子数组和。
public class Solution {
    public int FindGreatestSumOfSubArray(int[] array) {
        if(array == null || array.length == 0){
            return 0;
        }
        int tmp = 0;//当前子序列累积和
        int max = Integer.MIN_VALUE;
        for(int i = 0; i < array.length; i++){
            if(tmp <= 0){//如果已经小于0，从新开始计算
                tmp = array[i];
            }
            else{//否则继续累加
                tmp += array[i];
            }
            if(tmp > max){//如果大于以前最大的累加和，更新最大累加和
                max = tmp;
            }
        }
        return max;
    }
}
```

##### 31计算整数中1出现的次数（从1到n整数中1出现的次数）

```
//思想：分别统计每一位上1出现的次数。本位可能和高位和低位有关，因此需计算每一轮中的高位和低位是什么。然后根据本位的值的不同计算本位1出现次数。本位是0、1、其他的时候计算方法是不同的
//开始高低本位都错了，结果计算也错了，但是思想是对的，找规律
public class Solution {
    public int NumberOf1Between1AndN_Solution(int n) {
        if(n <= 0){
            return 0;
        }
        if(n < 10){
            return 1;
        }
        int count = 0;
        //i表示位，个十百千万。从十位开始
        for(int i = 1; n/i != 0; i *= 10){
            int high = n/(i*10);//高位
            int low = n%i;//低位
            int mid = (n%(i*10)-low)/i;//本位
                switch(mid){
                    case 0: count += high*i;break;
                    case 1: count += high*i + low + 1;break;
                    default: count += (high+1)*i;break;
                }
        }
        return count;
    }
}
```

##### 32把数组排成最小的数

```
//思想：就是设置一种新的比较方法用来进行两两之间的排序。可以使用Arrays.sort方法，然后自定义compare函数。
//第一遍的时候这道题学到的东西非常多，主要是String相关库函数的使用
//包括String类的compareTo函数，数组，集合等类型的sort函数，以及comparator接口
import java.util.ArrayList;
import java.util.Arrays;//开始没有导入，报错半天才知道怎么处理，有个疑问怎么知道函数是不是库函数，知道之后又怎么找
import java.util.Comparator;

public class Solution {
    public String PrintMinNumber(int[] numbers) {
        if(numbers.length <= 0){//后来调试的时候才发现没有写异常特殊处理的
            return "";
        }
        String[] str = new String[numbers.length];//新建字符串数组用来进行处理，排序比较之类的sort
        for(int i = 0; i < numbers.length; i++){
            str[i] = new Integer(numbers[i]).toString();
        }
        
        Arrays.sort(str, new Comparator<String>(){//实现comparator接口(实现比较规则），然后通过arrays.sort进行分类
            public int compare(String s1, String s2){
                String s3 = s1 + s2;
                String s4 = s2 + s1;
                return s3.compareTo(s4);//String类型默认的比较方法，根据第一个不同字符的字典未知进行比较，大于括号中元素则返回大于0
            }
        });
        StringBuilder sb = new StringBuilder(str[0]);//新建StringBuilder类型，用来进行字符串拼接操作，效率比较高。
        for(int i = 1; i < numbers.length; i++){
            sb.append(str[i]);
        }
        return sb.toString();//StringBuilder类型转换成String类型
    }
}
```

##### 33求按从小到大顺序的所有丑数

```
public class Solution {
    public int GetUglyNumber_Solution(int index) {
        //核心思想，创建一个辅助丑数数组，维护三个指针，分别代表当前*235的值，每次选出最小的作为新的元素的值，然后相应指针向后进位就行。
        if(index <= 0)
            return 0;
        int m2=0,m3=0,m5=0;
        int uglynumber = 1; 
        int[] uglist = new int[index];//丑数数列
        uglist[0] = 1;//初始值
        for(int i=1; i<index; i++){
            uglist[i] = min(uglist[m2]*2, uglist[m3]*3, uglist[m5]*5);//min选出来的应该处理一下
            if(uglist[m2]*2 == uglist[i])//等于的情况就是刚才min选出来的，这里会自动加1处理
                m2++;//这里肯定是在已有的丑数数列中加的
            if(uglist[m3]*3 == uglist[i])
                m3++;
            if(uglist[m5]*5 == uglist[i])
                m5++;
        }
        return uglist[index-1];
    }
    
    private int min(int m2, int m3, int m5){
        int min = Math.min(m2, Math.min(m3, m5));
        return min;
    }
}
```

##### 34找到字符串中第一次只出现一次的字符-返回位置

```
//思想：建立一个map，key是character。value是次数。遍历str，响应key的value+1；结束之后再遍历一次map，每次取相应的value。是1的返回。感觉比较low，可能还有更好的方法。
//重点：遍历取的时候是根据str的字符遍历的因此第一个取到的1次数就是第一个出现的
//这道题主要是对map的掌握不够，泛型不能使用基础类型，只能是引用类型，因此可以使用包装类，可以自动拆箱
//然后返回异常的时候，不要只想着返回0，一般返回-1
import java.util.*;

public class Solution {
    public int FirstNotRepeatingChar(String str) {
        if(str.length() <= 0){
            return -1;
        }
        Map<Character, Integer> m = new HashMap<Character, Integer>();
        int j;//这里定义一个临时变量，获取某个值已经出现的次数
        for(int i = 0; i < str.length(); i++){
            if(m.get(str.charAt(i)) == null){
                j = 0;
            }
            else{
                j = m.get(str.charAt(i));
            }
            m.put(str.charAt(i),j+1);
        }
        for(int i = 0; i < str.length(); i++){
            if(m.get(str.charAt(i)) == 1){
                return i;
            }
        }
        return -1;
    }
}
```

##### 35统计数组中的逆序对个数对1000000007取模

```
//思想：运用递归和归并排序的思想，递归对左右块进行排序，下面的代码都是对左右块进行排序的。实际上没有对某一块内部进行排序的逻辑，都是划分成左右块进行比较的。
//不会没思路，看的答案，这个应该是归并排序的思想。递归对左右块之间进行比较，然后合并，然后继续对更大的左右块进行比较。
public class Solution {
    public int InversePairs(int [] array) {
        if(array == null || array.length <= 0){
            return 0;
        }
        int[] copy =new int[array.length];
        int count = InversePairs_wds(array, copy, 0, array.length - 1);
        return count;
    }
    
    public int InversePairs_wds(int[] array, int[] copy, int low, int high){
        if(low == high){//最小分到1
            return 0;
        }
        int mid = (low + high) >> 1;//分治法，从中间分开分成左右，递归
        int leftcount = InversePairs_wds(array, copy, low, mid);//计算左边内部的逆序对数
        int rightcount = InversePairs_wds(array, copy, mid + 1, high);//计算右边内部的逆序对数
        
        //这里递归的思想体现的比较好，==下面没有某一块内部的比较。都是左右两块的比较==。大块的比较都会先递归成最小的块然后比较。按调用栈向上调用。
        int count = 0, i = mid, j = high;
        int copyPointer = high;//复制到copy数组的“指针”
        while(i >= low && j >= mid + 1){//从大到小遍历左右的数组，比较左右两块之间逆序对的个数
            if(array[i] > array[j]){//如果左边的i元素存在大于右边的j元素
                count += j - mid;//统计的逆序对数为右边剩下的元素个数
                copy[copyPointer--]  = array[i--];//将左边较大的值复制到copy数组当中，并将copy数组的指针和左边i指针向左移
                count %= 1000000007;
            }
            else{//如果左边当前最大元素i不大于右边当前元素，右边当前元素就是最大的，将右边当前元素加入到copy数组当中，并将j和copy指针向左移动
                copy[copyPointer--] = array[j--];
            }
        }
        while(i >= low){//如果左边还剩下值,加到copy中
            copy[copyPointer--] = array[i--];
        }
        while(j >= mid + 1){//如果右边还有，加入到copy中
            copy[copyPointer--] = array[j--];
        }
        for(int s=low; s<=high; s++)//这步是必须要有的，相当于将左右块排序之后合并了，copy数组作用体现在这里，当做临时数组
        //copy只是每次递归的临时变量，congarray中取的值进行比较。并不能作为最后的返回值返回。要再赋给array进行返回。
        {
            array[s] = copy[s];
        }
        return (count+leftcount+rightcount)%1000000007;//统计左右内部的逆序对数和之间的逆序对数
    }
}
```

##### 36输入两个链表-找出他们的第一个公共节点

```
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        if(pHead1 == null || pHead2 == null){
            return null;
        }
        //最开始想到的是蛮力，即遍历一个链表的每个元素，从第二个里面遍历找相同节点时间复杂度o(n*m)
        //第二个想到的是用栈，因为从后往前的话只用比较对应的元素就行，这样就需要两个辅助栈，时间复杂度o(n+m)
        //第三种想到的是，既然问题可以只比较对应的，那么从前边遍历能不能行呢。其实长短不一的问题主要在前边，因此只要把长的前面多出来的去掉就行了。
        ListNode p1 = pHead1;
        ListNode p2 = pHead2;
        int l1 = 0, l2 = 0;
        while(p1 != null){//先找到p1的长度
            l1++;
            p1 = p1.next;
        }
        while(p2 != null){//找到p2的长度
            l2++;
            p2 = p2.next;
        }
        
        p1 = pHead1;//重置到起始位置
        p2 = pHead2;
        if(l1 >= l2){//分情况讨论每种情况，哪个链表该调整起始位置
            for(int i = 0; i < l1 - l2; i++){
                p1 = p1.next;
            }
        }
        else{
            for(int i = 0; i < l2 - l1; i++){
                p2 = p2.next;
            }
        }
        
        while(p1 != p2 && p1 != null){//任选一个链表开始查找
            p1 = p1.next;
            p2 = p2.next;
        }
        return p1;
    }
}
```

##### 37统计一个数字在排序数组中出现的次数

```
//排序数组找东西实际上就是用二分法，然后就是针对不同情况的策略，注意递归结束条件和每次递归缩减没缩减范围，递归一定要全部情况都有范围减小，不然可能就会死循环。
//思想：直接分开，然后判断左边最大的和要找的数的关系。然后决定是否要找两块的，还是只找一块就行。
public class Solution {
    public int GetNumberOfK(int [] array , int k) {
        if(array == null || array.length == 0){
            return 0;
        }
        return GetNumberOfk_wds(array, 0, array.length - 1, k);
    }
    
    private int GetNumberOfk_wds(int [] array, int low, int high, int k){
        if(high < low){
            return 0;
        }
        int mid = (low+high) >> 1;
        int countr = 0, countl = 0, count = 0;//左右统计次数
        if(array[mid] < k){//如果左边最大的小于k，那么k都在右边
            countr = GetNumberOfk_wds(array, mid + 1, high, k);
        }
        else if(array[mid] > k){//如果左边最大的大于k,那么k都在左边
            countl = GetNumberOfk_wds(array, low, mid - 1, k);//这里无限循环了，本来写的是mid后来发现array[mid]不符合了就不用再看了。
        }
        else{//如果等于，那么左右两边都有
            count++;
            countl = GetNumberOfk_wds(array, low, mid - 1, k);
            countr = GetNumberOfk_wds(array, mid + 1, high, k);
        }
        return count + countl + countr;
    }
}
```

##### 38求树的深度

```
//看起来很简单，但是想到还是挺难得，主要思想子树高度加1
//思想：每次递归比较左子树的高度和右子树的高度。比较谁比较高，然后加上本节点的高度1返回
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public int TreeDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        int l = TreeDepth(root.left);//左子树高度
        int r = TreeDepth(root.right);//右子树高度
        return (l > r)?(l+1):(r+1);//比较高的加上本节点
    }
}
```

##### 39数组中两个只出现一次的数字

```
//思想：首先思考如果是只有一个出现一次的数字怎么办，应该直接对所有元素异或，因为其他元素都是成对的，因此最后的结果就是只有一个的数字。
//如果是两个只出现一次的数字，这时，需要分成两组，只需将所有元素异或，最后出现1的位置就是两个元素不同的地方，取第一个1的位置，然后遍历所有元素按照对应位置是不是1分成两组异或两组最后的结果就是两个数字。
//num1,num2分别为长度为1的数组。传出参数
//将num1[0],num2[0]设置为返回结果
import java.util.*;

public class Solution {
    public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
/*
//自己的拙劣解法，空间复杂度n时间复杂度n
//感觉很简单，直接用map统计，但是感觉应该有更好的解法
        Map<Integer, Integer> m = new HashMap<Integer, Integer>();
        for(int i = 0; i < array.length; i++){
            int tmp = 0;
            if(m.containsKey(array[i])){
                tmp = m.get(array[i]);
            }
            m.put(array[i], tmp + 1);
        }
        for(int i = 0; i < array.length; i++){
            if(m.get(array[i]) == 1 && num1[0] == 0){
                num1[0] = array[i];
            }
            else if(m.get(array[i]) == 1 && num1[0] != 0){
                num2[0] = array[i];
            }
        }
        */
        //收回我的错误言论，这道题实际上非常难，主要复杂度要求是1
        //这块是遍历出位中第一个1的位置n
        int m = 0;//用来进行迭代异或的变量
        int n = 0;
        for(int i = 0; i < array.length; i++){//得到所有值异或之后的结果
            m ^= array[i];
        }
        for(int i = 0; i < 32; i++) {//java中int类型是32位
            if(m == 1){
                n = i;
                break;
            }
            m >>= 1;
        }
        //这里是核心
        for(int i = 0; i < array.length; i++){
            if(((array[i] >> n) & 1) == 1){//如果向右移动相同位置然后跟1相与的结果是1那么就是第一类的
                num1[0] ^= array[i];
            }
            else{
                num2[0] ^= array[i];
            }
        }
        
    }
}
```

##### 40输出所有和为s的连续正数序列

```
//思想：记录连续序列的start和end；从start=1，end=2开始，如果大，后边向后移动，如果小，前边也向后移动，相等就添加到链表中
import java.util.ArrayList;
public class Solution {
    public ArrayList<ArrayList<Integer>> FindContinuousSequence(int sum) {
        int start = 1;
        int end = 2;
        int ssum = start + end;
        ArrayList<ArrayList<Integer>> All = new ArrayList<ArrayList<Integer>>();
        while(start < end && end <= sum/2 + 1){
            if(ssum == sum){//如果相等了，直接添加到链表中
                ArrayList<Integer> array = new ArrayList<>();
                for(int i = start; i <= end; i++){
                    array.add(i);
                }
                All.add(array);
                ssum -= start++;
                ssum += ++end;
                continue;
            }
            else if(ssum > sum){//如果大，头部向后移动
                ssum -= start++;
                continue;
            }
            else if(ssum < sum){//如果小，尾部向后移动
                ssum += ++end;
                continue;
            }
        }
        return All;
    }
}
```

##### 41和为S的两个数字且乘积最小

```
//思想就是从头和尾搞两个指针，分别从头和尾开始相加计算，小了头++，大了尾--
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> FindNumbersWithSum(int [] array,int sum) {
        ArrayList<Integer> arlist = new ArrayList<>(2);//返回值链表
        int start = 0, end = array.length - 1;//开始和结束的指针
        int min = Integer.MAX_VALUE;//选出的两个数的乘积和最小
        while (start < end){
            if(array[start] + array[end] == sum && (array[start] * array[end] < min)){//如果符合条件且是乘积最小的
                arlist.add(0, array[start]);
                arlist.add(1, array[end]);
                start++;
                end--;
                min = array[start] * array[end];
            }
            else if(array[start] + array[end] < sum){
                start++;
            }
            else{
                end--;
            }
        }
        return arlist;
    }
}
```

##### 42左旋转字符串

```
//思想就是，分为两个各调用reverse，然后整体再reverse。注意reverse实现又是头尾指针向内加加减减。
public class Solution {
    public String LeftRotateString(String str,int n) {
        if(n <0 || n > str.length()){
            return "";
        }
        char[] ch = new char[str.length()];
        ch = str.toCharArray();
        reverse(ch, 0, n - 1);
        reverse(ch, n, str.length() - 1);
        reverse(ch, 0, str.length() - 1);
        /*
        StringBuffer newstr = new StringBuffer();
        newstr.append(ch);
        return newstr.toString();
        */
        return String.valueOf(ch);
    }

    private void reverse(char[] ch, int start, int end){
        char tmp;
        while(start < end){
            tmp = ch[start];
            ch[start] = ch[end];
            ch[end] = tmp;
            start++;
            end--;
        }
    }
}
```

##### 43翻转单词顺序列

```
//实际上这道题不算难，难点就是怎么判断每个单词起始和结束位置，一个是首先判断start是空格的时候，start和end都++，然后每次翻转完一次之后star位置更新到end，注意end什么时候可以判断是单词结尾，还可能有到头的情况。
//另一个点就是每次反转的时候怎么把结果传递到另一个函数中，可以设置全局变量，注意每次都要在翻转函数中更新全局变量。
public class Solution {
    String  newstr = new String();
    public String ReverseSentence(String str) {
        int start= 0, end = 0;
        newstr = new String(str);
        while(start < newstr.length()){
            if (newstr.charAt(start) == ' ') {//当start和end都在空格未知的时候
                start++;
                end++;
            }
            else if(newstr.charAt(end) == ' '){//如果end在一个单词的末尾的空格了，翻转，之后将start改到end的位置
                reverse(newstr, start, --end);
                start = ++end;
            }
            else if( end == newstr.length() - 1){//如果末尾不是空格，但是end到末尾了。
                reverse(newstr, start, end);
                start = ++end;
            }
            else{//如果start在一个单词的开头了，但是end不在一个单词的末尾，end++
                end++;
            }
        }
        reverse(newstr, 0, newstr.length() - 1);
        return newstr;
    }

    private void reverse(String str, int start, int end){
        char[] ch = str.toCharArray();
        char tmp;
        while(start < end){
            tmp = ch[start];
            ch[start] = ch[end];
            ch[end] = tmp;
            start++;
            end--;
        }
        newstr = String.valueOf(ch);
    }
}
```

##### 44扑克牌顺子

```
//思想主要是，排序之后计算大小王个数，然后顺序遍历计算不是顺子之间的差值，看两者能不能满足，注意如果出现相同的牌说明false（除了大小王）
import java.util.Arrays;

public class Solution {
    public boolean isContinuous(int [] numbers) {
        if(numbers == null ||numbers.length == 0){
            return false;
        }
        //老是想arraylist sout方法，但是实际上是Arrays的方法
        Arrays.sort(numbers);//先排序
        int k = 0;//给大小王计数的
        int count = 0;//中间需要填补的大小
        for(int i = 0; i < numbers.length - 1; i++){
            if(numbers[i] == 0){
                k++;
            }
            else if(numbers[i + 1] == numbers[i]){//相等的需要返回false
                return false;
            }
            else if(numbers[i + 1] - numbers[i] != 1){
                count += numbers[i + 1] - numbers[i] - 1;//累加中间需要填补的大小
            }
        }
        if(k >= count){
            return true;
        }
        return false;
    }
}
```

##### 45圆圈中最后剩下的数

```
//这道题最好的方法就是模拟，普通方法是使用循环链表，每次遍历到结尾就从头开始。
//模拟方法就是推出数学公式，然后做一个逆映射，从最后一个孩子开始往前推。
// 思想：通过%映射，使用上一次孩子的位置映射计算当前孩子的位置，最后剩一个孩子的情况，位置是0。
public class Solution {
//方法一：分析模拟法
    public int LastRemaining_Solution(int n, int m) {
        if(n <= 0 || m <= 0) {
            return -1;
        }
        int i = 2;//这个表示从少到多的时候每次的人数n，这里从2开始计算
        int k = 0;//因为剩1个的时候，统计是从0开始的
        while(i <= n){//这里从两个开始
            //下面这里第一次计算出剩两个的时候的k，每次都是计算剩i时候的位置，所以最后i到n了，还是要计算一次
            k = (k + i + m)%i;//找规律计算出来的，实际上+i是为了体现出计算过程，这里不加结果是一样的
            i++;
        }
        return k;
    }
//方法二：环形链表模拟法
public int LastRemaining_Solution(int n, int m){
	if(n <= 0 || m <= 0){
		return -1;
	}
	
	List<Integer> list = new LinkedList<>();
	for(int i = 0; i < n; i++){
		list.add(i);
	}
	int start = 0;
	int index = 0;
	while(list.size() > 1){
		for(int i = 1; i < m; i++){
			index = (index + 1) % list.size();
		}
		list.remove(index);
	}
	return list.get(0);
}
```

##### 46求1+2+3+4+5+...n-不能使用乘除法-条件判断if-各种循环for-while-三目运算符等

```
//主要思想就是一个短路&&，前半句起判断终止作用，后半句起业务作用。
//主要就是使用短路特性，判断传入参数的大小
public class Solution {
    public int Sum_Solution(int n) {
        int sum= n;
        boolean s = (n>0)&&((sum+=Sum_Solution(n-1))>0);
        return sum;
    }
}
```

##### 47不使用加减乘除实现加法

```
//思想：因为实际上计算都是通过二进制来的，计算二进制中需要进位和不需要进位的就行了，但是注意要循环，进位之后可能还会进位。
public class Solution {
    //提前看过书了，这道题有思路，思路就是把加法分解为进位和不进位两个部分
    public int Add(int num1,int num2) {
        while(num2 != 0){
            //不进位部分使用异或1 0 = 1  1 1 = 0 0 0 = 0
            int tmp = num1 ^ num2;
            //进位部分使用& 1   1 = 1  剩下的等于0
            num2 = num1 & num2;
            num2 <<= 1;
            num1 = tmp;
        }
        return num1;
    }
}
```

##### 48字符串转换成整数

```
// 思想：注意+-号，剔除掉。然后就是边界条件。
import java.util.*;
import java.lang.Math;

public class Solution {
    public int StrToInt(String str) {
        if(str == null || str.length() <= 0){
            return 0;
        }
        int flag = 1;
        if(str.charAt(0) == '+'){
            str = str.substring(1, str.length());// 这里需要注意不包含endindex位置的字符
        }else if(str.charAt(0) == '-'){
            str = str.substring(1, str.length());
            flag = -1;
        }
		
        int i  = 0;
        int result = 0;
        while(i < str.length() && str.charAt(i) >= '0' && str.charAt(i) <= '9'){
            if(result == 2147483640 && str.charAt(i) == '8' && flag == -1){ // 这里是一个需要注意的，负数的表示范围比正数大1个，需要单独判断
                return -2147483648;
            }
            result += (str.charAt(i) - '0') * Math.pow(10.0, (str.length() - i - 1) * 1.0);
            i++;
        }
        if(i != str.length()){
            return 0;
        }
        return result * flag;
    }
}
```


##### 49数组中重复的数字

```
//这种方法时间复杂度是On空间复杂度是1
//从头到尾遍历，因为题目是大小为n的数，数字的范围是0——n-1因此直接排序，将对应数字放到对应的位置上，两者不同互换。继续比较当前位置，位置对了向下遍历，直到遇到重复数字。
public class Solution {
    public boolean duplicate(int numbers[],int length,int [] duplication) {
        //思想就是从头到尾遍历，看数字是不是在他自己应该在的位置上，如果在，向后遍历，
        // 不在就放到该放的位置上，如果比较的过程中碰到相同的了，返回。
        if(length <= 1){//判断异常情况
            return false;
        }
        //最多n次，因为n次就会将数组排序完，排序完都没发现说明false
        int i = 0;
        while(i < length){//从头开始遍历
            if(numbers[i] == i){//如果和元素和它应该在的位置的的数一样，向后遍历
                i++;
                continue;
            }
            else if (numbers[i] == numbers[numbers[i]]){//如果不一样，并且和应该在的位置的数相等返回true
                duplication[0] = numbers[i];
                return true;
            }
            else{//这里注意交换顺序，顺序变了是不行的，因为numbers[i]的值会变
                int tmp = numbers[numbers[i]];
                numbers[numbers[i]] = numbers[i];
                numbers[i] = tmp;
            }
        }
        return false;
    }
}
```
##### 50构建乘积数组、给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]*A[i+1]…*A[n-1]。不能使用除法。

```
//思想：将B[i]的因子视为一个矩阵，每一行的左边和右边视为C[i]、D[i],从上都下构建C[i]、从下到上构建D[i]
import java.util.ArrayList;
public class Solution {
    public int[] multiply(int[] A) {
        int[] B = new int[A.length];
        int[] C = new int[A.length];
        int[] D = new int[A.length];
        C[0] = 1;
        D[A.length - 1] = 1;
        for(int i = 1; i < A.length; i++){
            C[i] = C[i - 1] * A[i - 1];
        }
        for(int i = A.length - 2; i >= 0; i--){
            D[i] = D[i + 1] * A[i + 1];
        }
        for(int i = 0; i < A.length; i++){
            B[i] = C[i] * D[i];
        }
        return B;
    }
}
```

##### 51 正则表达式匹配


```
//思想就是区分第二个是不是*，不是好办，是的话比较复杂，难以进行条件分类，因为不知道*前面的字符要匹配多少个str的字符，可能模式的后面也是相同的，因此需要||两种情况，一种一个不匹配，模式直接向后移动两个、一种匹配一个str后移一个，模式不变然后重新来匹配。这样就能覆盖所有情况了，不然实在太复杂。
public class Solution {
//通过这道题又想起来当要使用数组复制的时候尽量不要直接复制原来的数组，多两个变量表示数组的index就行了，再创建个函数
    public boolean match(char[] str, char[] pattern)
    {
        if(str == null || pattern == null){
            return false;
        }
        int i = 0, j = 0;
        return matchcore(str, pattern, i, j);
    }
    
    public boolean matchcore(char[] str, char[] pattern, int i, int j){
        if(j == pattern.length && i != str.length){//pattern空了，str不空返回false
            return false;
        }
        if(i == str.length && j == pattern.length){//两个都空了，返回true
            return true;
        }
    //模式第2个是*，且字符串第1个跟模式第1个匹配,分2种匹配模式；如不匹配，模式后移2位,如匹配，str向后移动一位继续开始匹配
    if (j + 1 < pattern.length && pattern[j + 1] == '*') {
        if ((i != str.length && pattern[j] == str[i]) || (pattern[j] == '.' && i != str.length)) {
            return matchcore(str, pattern, i, j + 2)//模式后移2，视为x*匹配0个字符
 //                   || matchcore(str, pattern, i + 1, j + 2)//视为模式匹配1个字符
                    || matchcore(str,  pattern, i + 1,j);//*匹配1个，再匹配str中的下一个
        } else {
            return matchcore(str, pattern, i, j + 2);
        }
    }
    //模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false
    if ((i != str.length && pattern[j] == str[i]) || (pattern[j] == '.' && i != str.length)) {
        return matchcore(str, pattern, i + 1, j + 1);
    }
    return false;
    }
}
```

##### 52 表示数值的字符串

```
//思想：这道题不需要使用递归，按顺序遍历就行，只关注特殊符号，数字单独使用一个函数过滤。然后特殊符号遵循[sign]intergral-digits[.[fractional-digits]][e|E[sign]exponential-digits]，其中[]表示不一定有，intergral-digits表示数字sign表示正负号
//还有一种使用正则表达式的写法,如下
/*
public class Solution {
    public boolean isNumeric(char[] str) {
        String string = String.valueOf(str);
        return string.matches("[\\+-]?[0-9]*(\\.[0-9]*)?([eE][\\+-]?[0-9]+)?");
    }
}
*/
public class Solution {
    public boolean isNumeric(char[] str) {
        if(str == null){
            return false;
        }
        return isNumericCore(str, 0);
    }
    //核心部分，传递index
    private boolean isNumericCore(char[] str, int index){
        //1首先判断是不是+—号开头
        if(index < str.length && (str[index] == '+' || str[index] == '-')){
            index = isShuzi(str, index + 1);
        }
        //2不是直接过滤掉数字，并从数字的下一个开始
        index = isShuzi(str, index);
        //3判断是不是.，是的话，过滤掉.后边的数字。并且注意下标的范围
        if(index < str.length && str[index] == '.'){
            index = isShuzi(str, index + 1);
        }
        //4过滤掉了e前边的数字了，开始判断是不是e，如果e后面没有数字了，直接错误
        if(index == str.length - 1 && (str[index] == 'e' || str[index] == 'E')){
            return false;
        }
        //如果e后边有数字，判断是不是+-号开头，过滤掉后边的数字，并返回数字的下一个位置
        if(index < str.length && (str[index] == 'e' || str[index] == 'E')){
            if(str[index + 1] == '+' || str[index + 1] == '-'){
                index = isShuzi(str, index + 2);
            }
            else{
                index = isShuzi(str, index + 1);
            }
        }
        //如果到头了就说明成功了，没到头说明e后面格式不对
        if(index == str.length){
            return true;
        }
        return false;
    }
    //这个是遍历是否有一串数字,有数字返回数字后面的index的位置没有数字直接返回原来的index
    private int isShuzi(char[] str, int index){
        while((index < str.length && str[index] >= '0') && str[index] <= '9'){
            index++;
        }
        return index;
    }
}
```
##### 53 字符流中第一个不重复的数字

```
import java.util.*;

public class Solution {
    //思想：使用队列，使用辅助数组，辅助数组表示字符出现次数，每次出队列的时候计算头元素是不是只出现一次，不是向后遍历。
    //重点空格是最小的ascii码字符，之前一直以为是‘0’，‘0’一般是用来计算字符的123456789用的。
    Queue<Character> queue = new LinkedList<>();
    int[] tmp = new int[128];
    //Insert one char from stringstream
    public void Insert(char ch)
    {
        tmp[ch - ' '] += 1;
        if(tmp[ch - ' '] == 1){
            queue.offer(ch);
        }
    }
  //return the first appearence once char in current stringstream
    public char FirstAppearingOnce()
    {
        while(!queue.isEmpty() && tmp[queue.peek() - ' '] != 1){
            queue.poll();
        }
        if(queue.isEmpty()){
            return '#';
        }
        return queue.peek();
    }
}
```

##### 54 链表中环的入口节点

```
/*
 public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
*/
import java.util.*;
public class Solution {
//最初的思想：将已经遍历到的节点加入到一个哈希表中，每次读下一个节点判断是否在哈希表中不在的话就添加。在的话就找到了。时间复杂度n，空间复杂度n。
    public ListNode EntryNodeOfLoop(ListNode pHead)
    {
        Map<Integer, Boolean> map = new HashMap();
        while(pHead.next != null){
            if(map.containsKey(pHead.val)){
                return pHead;
            }
            map.put(pHead.val, true);
            pHead = pHead.next;
        }
        return null;
    }
}
```

```
/*大神 思想：
- 1：快慢指针，1步和2步，找到相交的点
- 2：环长度，快指针比慢指针多走一个环的长度。又快指针走的是慢指针的2倍。因此慢指针走的就是一个环的长度。
- 3：环入口：快指针回到起点。两个相同速度走。碰到就是环入口。*/
import java.util.*;
public class Solution {
    public ListNode EntryNodeOfLoop(ListNode pHead){
        ListNode k = pHead;
        ListNode m = pHead;
        while(k.next != null){
            k = k.next.next;
            m = m.next;
            if (m == k){
                k = pHead;
                while(k != m){
                    k = k.next;
                    m = m.next;
                }
                return k;
            }
        }
        return null;
    }
}

```
##### 55 删除链表中重复的元素

```
/*
 public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    // 思想：递归，这题挺注意细节的。每次递归把与当前头结点相同的节点去掉，返回第一个不同的。
    public ListNode deleteDuplication(ListNode pHead)
    {
        // 最后一个节点返回的东西
        if(pHead == null || pHead.next == null){
            return pHead;
        }
        // 这个是去除和当前节点相同的节点的逻辑
        if(pHead.val == pHead.next.val){
            ListNode p = pHead;
            while(p != null && p.val == pHead.val){
                p = p.next;
            }
            return deleteDuplication(p);
        }
        // 如果没有相同节点，直接递归下一个节点。
        pHead.next = deleteDuplication(pHead.next);
        // 注意返回值一定要有，每层连接完pHead.next之后肯定要返回pHead的。
        return pHead;
    }
}
```
##### 56 二叉树的下一个节点

```
/*
public class TreeLinkNode {
    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null;

    TreeLinkNode(int val) {
        this.val = val;
    }
}
*/
// 思想：分情况讨论，如果有右子树，找右子树最左节点；否则如果是父节点左子树，返回父节点；否则，找父节点中是其父节点左子树的节点，返回其父节点。
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        if (pNode == null){
            return null;
        }
        if (pNode.right != null) {
            TreeLinkNode tmp = pNode.right;
            while (tmp.left != null){
                tmp = tmp.left;
            }
            return tmp;
        } else if (pNode.next != null && pNode == pNode.next.left) {
            return pNode.next;
        } else {
            TreeLinkNode tmp = pNode;
            while (tmp.next != null && tmp != tmp.next.left){
                tmp = tmp.next;
            }
            if (tmp.next == null)
                return null;
            return tmp.next;
        }
    }
}
```
##### 57 对称的二叉树

```
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
// 思想： 虽然默认方法传入的是一个根节点，但是之后的判断需要比较左子节点和右子节点。因此需要定义一个两个参数的方法。
// 思想： 比较当前两个节点是否相等。相等就继续互相比较当前两节点的左右子节点。比较的方法实质上就是正常先序遍历左节点，先序从右遍历右节点（感觉就是跳出正常思维吧，正常一般都是先遍历左节点）
public class Solution {
    boolean isSymmetrical(TreeNode pRoot)
    {
        if(pRoot == null){
            return true;
        }
        return areSymmetrical(pRoot.left, pRoot.right);
    }
    boolean areSymmetrical(TreeNode p1, TreeNode p2){
        if (p1 == null && p2 == null){
            return true;
        } else if (p1== null || p2 == null){
            return false;
        } else if (p1.val != p2.val){
            return false;
        }
        return areSymmetrical(p1.left, p2.right) && areSymmetrical(p1.right, p2.left);
    }
}
```
##### 58 按之字顺序打印二叉树

```
//思想：还感觉挺简单的，但是写起来好复杂的感觉
// 建立两个栈，边遍历一个栈边添加另一个栈边填充一个list。栈空了就可以更新list遍历另一个栈了。就是两个栈相互赋值。注意的是创建一个变量，用来判断当前循环应该遍历哪个栈。
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Stack; 
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}
*/
// 两个栈，相互存
public class Solution {
    public ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        ArrayList<ArrayList<Integer>> llist = new ArrayList<ArrayList<Integer>>();
        ArrayList<Integer> list = new ArrayList<Integer>();
        //stack0负责从左到右stack1负责从右到左。
        Stack<TreeNode> stack0 = new Stack<TreeNode>();
        Stack<TreeNode> stack1 = new Stack<TreeNode>();
        TreeNode node = null;
        stack0.push(pRoot);
        // 判断该栈0还是栈1执行
        boolean iszero = true;
        // 心急之下也没对边界条件进行判断
        if(pRoot == null){
            return llist;
        }
        // 有不空的就行
        while(!(stack0.isEmpty() && stack1.isEmpty())){
            if(iszero){
                    node = stack0.pop();
                    list.add(node.val);
                    if(node.left != null){
                        stack1.push(node.left);
                    }
                    if(node.right != null){
                        stack1.push(node.right);
                    }
                // 一个栈空了就将此list添加到返回的list中。
                if(stack0.isEmpty()){
                    // 神坑：list是引用类型，每次存到llist里面的是list本身，如果list清空和改变了，直接影响llist，因此需要加入新建的对象。
                    llist.add(new ArrayList<Integer>(list));
                    list.clear();
                    iszero = !iszero;
                }
            } else {
                    node = stack1.pop();
                    list.add(node.val);
                    if(node.right != null){
                        stack0.push(node.right);
                    }
                    if(node.left != null){
                        stack0.push(node.left);
                    }
                if(stack1.isEmpty()){
                    llist.add(new ArrayList<Integer>(list));
                    list.clear();
                    iszero = !iszero;
                }
            }
        }
        return llist;
    }
}
```


##### 59 把二叉树打印成多行

```
//感觉是很简单的一道题目，没想到还是栽了，难点是多行打印
//思想：队列实现不用说了。主要定义两个变量，一个表示当前行剩下的，一个表示下一行有多少个。每次当前行打印完了，填充返回值，重置下一行。
import java.util.ArrayList;
import java.util.LinkedList;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        ArrayList<ArrayList<Integer>> llist = new ArrayList<ArrayList<Integer>>();
        ArrayList<Integer> list = new ArrayList<Integer>();
        LinkedList<TreeNode> queue =new LinkedList<TreeNode>();
        if(pRoot == null){
            return llist;
        }
        queue.add(pRoot);
        TreeNode node;
        int leftnodes = 1;
        int nextnodes = 0;
        while(!queue.isEmpty()){
            node = queue.poll();
            list.add(node.val);
            leftnodes --;
            if(node.left != null){
                queue.add(node.left);
                nextnodes ++;
            }
            if(node.right != null){
                queue.offer(node.right);
                nextnodes ++;
            }
            if(leftnodes == 0){
                llist.add(new ArrayList(list));
                list.clear();
                leftnodes = nextnodes;
                nextnodes = 0;
            }
        }
        return llist;
    }
    
}
```
##### 60 序列化二叉树

```
//思想：序列化：前序序列化，子节点为空的时候定义一个不同的符号表示null。然后序列化方法常见的有两种，一种是定长的，一种是加分隔符。加分隔符比较简单，用string.split就能直接分割。定长的话限制比较多，val不能超过设定长度。自己的方法设置的4位数。
//反序列化：同样前序接收。分隔符方法使用string.split分割。定长方法使用要取出str中指定位置字符串，但是又不能破坏原来的字符串，感觉用string.substring()有点麻烦，懒得改，直接用charAt()；然后直接前序接收就行了。注意要定义一个int变量用来记录遍历到的位置。
//自己的定长方法：这题开始都没看懂序列化是啥意思？转换成2进制？string？还要自己看书。。。
public class Solution {
    String temp = "";
    String Serialize(TreeNode root) {
        if(root == null){
            temp += "####";
            return "";
        }
        String tmp = String.format("%04d", root.val);
        temp += tmp;
        Serialize(root.left);
        Serialize(root.right);
        return temp;
  }
    //感觉还是递归比较省心吧
    //
    int count = 0;
    TreeNode Deserialize(String str) {
        if(str == "" || count >= 4 * str.length()){
            return null;
        }
        String tmp = String.valueOf(str.charAt(count));
        tmp += str.charAt(count + 1);
        tmp += str.charAt(count + 2);
        tmp += str.charAt(count + 3);
        if(tmp.equals("####")){
            count += 4;
            return null;
        }
        TreeNode temp = new TreeNode(Integer.parseInt(tmp));
        count += 4;
        temp.left = Deserialize(str);
        temp.right = Deserialize(str);
        return temp;
    }
}
```

```
//链接：https://www.nowcoder.com/questionTerminal/cf7e25aa97c04cc1a68c8f040e71fb84
//来源：牛客网
//牛客的分隔符方法。
public class Solution {
    public int index = -1;
    String Serialize(TreeNode root) {
        StringBuffer sb = new StringBuffer();
        if(root == null){
            sb.append("#,");
            return sb.toString();
        }
        sb.append(root.val + ",");
        sb.append(Serialize(root.left));
        sb.append(Serialize(root.right));
        return sb.toString();
  }
    TreeNode Deserialize(String str) {
        index++;
        int len = str.length();
        if(index >= len){
            return null;
        }
        String[] strr = str.split(",");
        TreeNode node = null;
        if(!strr[index].equals("#")){
            node = new TreeNode(Integer.valueOf(strr[index]));
            node.left = Deserialize(str);
            node.right = Deserialize(str);
        }
        
        return node;
  }
}
```
##### 61 二叉搜索树的第k个节点

```
//很简单的一道题，但是感觉学到了很多东西。注释表示了思想过程123
import java.util.ArrayList;
//思想:中序遍历是有序的，
public class Solution {
    ArrayList<TreeNode> array = new ArrayList<TreeNode>();
    TreeNode KthNode(TreeNode pRoot, int k)
    {
        if(pRoot == null || k <= 0){
            return null;
        }
        //2：这样中间层的是都返回去了，但是最上层的没有返回啊。最上层的一层之内可以当做是顺序执行，到这里还不满足，到最下面才返回。
        //不如直接放弃，不然虽然效率变高了但是感觉程序好难看
//        if(array.size() >= k){
//            return array.get(k - 1);
//        }
        if(pRoot.left != null){
            KthNode(pRoot.left, k);
        }
        array.add(pRoot);
        //用来调试的，这样方便查看调用栈，调到那里出问题了。
        //System.out.println("添加了："+pRoot.val);
        //1：想法不错，但是没法中断，这样不能中断整个调用栈，只返回给了上层。但是这种写法只有最上的一层返回值才有效。这样不行。
        //后来发现，放在这里不行，但是放在最上面，每次返回上层的栈只要满条件就一直返回到最上层了。
        if(pRoot.right != null){
            KthNode(pRoot.right, k);
        }

        //3: 这样就能够解决不够k的时候的问题了 
        // 可能稍微有点麻烦，写到这里并没有提高效率。
        if(array.size() >= k){
            return array.get(k - 1);
        }
        //堆栈中的return是无效的，只有最开始的那个才是有用的。
        //这样不行，因为最开始返回的调用栈栈底array还没有这多元素。所以可能要考虑换一种数据结构
        //return array.get(k - 1);
        //这个没有意义随便写就行。
        return null;
    }
}
```

```
//应该算正解吧，反正比我的简单，这个业务层很简洁。感觉很正式。
public class Solution {
        int i = 0;
        TreeNode t = null;
        TreeNode KthNode(TreeNode pRoot, int k)
        {
            //边界条件
            if (pRoot == null || k <= 0)
                return null;
            // 中序左边
            KthNode(pRoot.left, k);
            // 业务层
            i++;
            if (i == k)
                t = pRoot;
            // 中序右边
            KthNode(pRoot.right, k);
            // 返回值
            return t;
        }
```
##### 62 数据流的中位数

```
// 本能的想法是平衡二叉搜索树？红黑树？
// 看了剑指offer好像是挺好，但是实现比较复杂，一时半会可能写不完，还是堆比较简单
// 思想:前半边大顶堆，后半边小顶堆。中位数就是对顶元素之和的一半
import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.Queue;

public class Solution {
    // 优先队列实现大顶堆小顶堆，注意优先队列默认是小顶堆，大顶堆需要重写comparator对象内的compare方法.15好像是初始值，大小是能改变的
    Queue<Integer> minHeap = new PriorityQueue<Integer>();
    Queue<Integer> maxHeap = new PriorityQueue<Integer>(15, new Comparator<Integer>(){
        public int compare(Integer e1, Integer e2){
            return e2.compareTo(e1);
        }
    });
    //首先做一个规定，大顶堆和小顶堆依次获得元素。
    boolean flag = true;
    public void Insert(Integer num) {
        if(flag){
            if(!minHeap.isEmpty() && minHeap.peek() < num){
                minHeap.offer(num);
                maxHeap.offer(minHeap.poll());
            } else{
                maxHeap.offer(num);
            }
            flag = !flag;
        } else {
            if(!maxHeap.isEmpty() && maxHeap.peek() > num){
                maxHeap.offer(num);
                minHeap.offer(maxHeap.poll());
            } else{
                minHeap.offer(num);
            }
            flag = !flag;
        }
    }

    public Double GetMedian() {
        if(!flag){
            return maxHeap.peek()*1.0;
        } else {
            return (minHeap.peek() + maxHeap.peek())/2.0;
        }
    }
}
```
##### 63 滑动窗口的最大值

```
//思想：显然滑动窗口是队列实现的，然后建立一个表示滑动窗口最大值的队列。
//然后就是滑动窗口每次变动的时候考虑当前元素可能不可能是最大元素，是的话添加进去。不是的话就忽略
//每次循环的时候
//这道题要考虑的点很多，一一写下，看一看
import java.util.LinkedList;
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> maxInWindows(int[] num, int size)
    {
        ArrayList<Integer> list = new ArrayList<Integer>(num.length - size + 1);
        if(num == null || size <= 0){
            return list;
        }
        LinkedList<Integer> queue = new LinkedList<Integer>();
        for(int i = 0; i < num.length; i++){
            //1、这个队列的性质是后边的元素小于前边的元素。如果大于的话就要剔除前边的元素，应该从后先前开始剔除，因为是队列是降序的。
            //双端队列
            while (!queue.isEmpty() && num[queue.getLast()] < num[i]){
                queue.removeLast();
            }
            //2、去掉不合理的之后，直接添加到队列尾，就是说不管怎么样当前的都要添加到队列中
            queue.offer(i);
            //3、如果滑动窗口还没填充满，就不向最大值list填充
            if(i < size - 1){
                continue;
            }
            //4、如果当前队列头已经不在滑动窗口里面了就去掉
            if((i - queue.peek()) > (size - 1)){
                queue.poll();
            }
            //5、取出当前队列头
            list.add(num[queue.peek()]);
        }
        return list;
    }
}
```
##### 64 矩阵中的路径

```
//自己的想法：首先按照行列先后顺序查找符合str第一个字符的元素。从合适的开始判断是否适配。不符合继续下一个元素
//已经遍历过得需要标记一下。这里使用map标记。
//写不下去了，看的剑指offer书，发现用回溯法
//感觉还是写不下去，看了大神的写法，决定照抄。。。
import java.util.*;
public class Solution {
    public boolean hasPath(char[] matrix, int rows, int cols, char[] str)
    {
        // 标记数组，用来表示当前位置是否已经被遍历过。
        int flag[] = new int[matrix.length];
        for(int i = 0; i < rows; i++){
            for(int j = 0; j < cols; j++){
                if(hasPathCore(matrix, rows, cols, str, i, j, 0, flag)){
                    return true;
                }
            }
        }
        return false;
    }
    // k表示当前str该比较的位置
    private boolean hasPathCore(char[] matrix, int rows, int cols, char[] str, int i, int j, int k, int[] flag){
        int index = i * cols + j;
        // 如果已经超出边界范围、不等、或者已经遍历过了当前元素。直接返回false
        if(i < 0 || i > rows - 1 || j < 0 || j > cols - 1 || matrix[index] != str[k] || flag[index] == 1){
            return false;
        }
        // 如果当前已经遍历到最后一个元素了，就结束了
        if(k == str.length - 1){
            return true;
        }
        // 否则还在遍历中继续遍历
        flag[index] = 1;
        if(   hasPathCore(matrix, rows, cols, str, i - 1, j, k + 1, flag) 
           || hasPathCore(matrix, rows, cols, str, i + 1, j, k + 1, flag) 
           || hasPathCore(matrix, rows, cols, str, i, j - 1, k + 1, flag) 
           || hasPathCore(matrix, rows, cols, str, i, j + 1, k + 1, flag)){
            return true;
        }
        //下面这里开始没想到，这里才是回溯法的最根本体现。如果上下左右都没有合适的就直接退到前面一个匹配的节点。
        //调用栈的上一层应该是继续上一个节点的上下左右还没被遍历过得目标。如果还是都没有继续返回上一层。
        //不会出现反复进入同一个节点的情况，因为上一层是有序的调用上下左右。上不合适就下，下不合适就左。。。。。。直到合适或者不合适再跳到上一层。
        flag[index] = 0;
        return false;
    }
}
```
##### 65 机器人的运动范围

```
//思想：感觉不是很像回溯法，检查当前节点是否合理，然后直接递归查找周围的每次return的时候+1就是加上当前节点。
//不合理的返回0。
//注意这题是找到所有能到的点。而不是一条路径。
public class Solution {
    public int movingCount(int threshold, int rows, int cols)
    {
        if(threshold < 0 || rows < 0 || cols < 0){
            return 0;
        }
        //标记数组，标记当前点是否被遍历过
        int flag[] = new int[rows * cols];
        return movingCountCore(threshold, 0, 0, rows, cols, flag);
    }
    
    private int movingCountCore(int threshold, int i, int j, int rows, int cols, int[] flag){
        if(check(threshold, i, j, rows, cols, flag)){
            flag[i * cols + j] = 1;
            //重点是后面的+1，实际上这里才是唯一计数的地方，每次计数当前节点。
            return movingCountCore(threshold, i - 1, j, rows, cols, flag)
                + movingCountCore(threshold, i + 1, j, rows, cols, flag)
                + movingCountCore(threshold, i, j - 1, rows, cols, flag)
                + movingCountCore(threshold, i, j + 1, rows, cols, flag)
                + 1;
        } else {
            return 0;
        }
    }
    //这个函数用来检测是否满足给定条件，注意还要判断当前字段是否已经遍历过
    private boolean check(int threshold, int i, int j, int rows, int cols, int[] flag){
        if(i < 0 || j < 0 || i >= rows || j >= cols || flag[i * cols + j] == 1){
            return false;
        }
        int sum = 0;
        while(i != 0){
            sum += i % 10;
            i /= 10;
        }
        while(j != 0){
            sum += j % 10;
            j /= 10;
        }
        if(sum <= threshold){
            return true;
        }
        return false;
    }
}
```
